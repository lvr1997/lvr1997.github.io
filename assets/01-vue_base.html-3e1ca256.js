import{_ as t,p as e,q as o,w as c,s as a,Y as s,R as n}from"./framework-aa5c4115.js";const p={},l=a("p",null,[a("strong",null,"学习了这么久，总该留下点什么")],-1),u=s('<h2 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点" aria-hidden="true">#</a> 优缺点</h2><p>优点：</p><ol><li>数据驱动视图，对真实 dom 进行抽象出 virtual dom（本质就是一个 js 对象）， 并配合 diff 算法、响应式和观察者、异步队列等手段以最小代价更新 dom，渲染页面</li><li>组件化，组件用单文件的形式进行代码的组织编写，使得我们可以在一个文件里编写 html\\css（scoped 属性配置 css 隔离）\\js 并且配合 Vue-loader 之后，支持更强大的预处理器等功能</li><li>强大且丰富的 API 提供一系列的 api 能满足业务开发中各类需求</li><li>由于采用虚拟 dom，让 Vue ssr 先天就足</li><li>生命周期钩子函数，选项式的代码组织方式，写熟了还是蛮顺畅的，但仍然有 优 化 空 间</li><li>生态好，社区活跃</li></ol><h2 id="对mvvm模型的认识" tabindex="-1"><a class="header-anchor" href="#对mvvm模型的认识" aria-hidden="true">#</a> 对MVVM模型的认识</h2><p>相比于传统的MVC模式，新增了VM类，即ViewModel<br>通过将【模型】转化成【视图】和将【视图】转化成【模型】完成了双向数据绑定，前者实现方式是数据绑定，后者实现方式是DOM事件监听</p><h2 id="对虚拟dom的理解" tabindex="-1"><a class="header-anchor" href="#对虚拟dom的理解" aria-hidden="true">#</a> 对虚拟DOM的理解</h2><p>虚拟 dom 是相对于浏览器所渲染出来的真实 dom 的，在react，vue 等技术出现之前， 我们要改变页面展示的内容只能通过遍历查询 dom 树的方式找到需要修改的 dom 然后修改样式行为或者结构，来达到更新 ui 的目的。<br>这种方式相当消耗计算资源，因为每次查询 dom 几乎都需要遍历整颗 dom 树，如果建立一个与 dom 树对应的虚拟 dom 对象（ js 对象），以对象嵌套的方式来表示 dom 树，那么每次 dom 的更改就变成了 js 对象的属性的更改，这样一来就能查找 js 对象的属性变化要比查询 dom 树的性能开销小。</p><h2 id="vue内置指令" tabindex="-1"><a class="header-anchor" href="#vue内置指令" aria-hidden="true">#</a> vue内置指令</h2><p><code>v-bind</code> 在html元素的属性上面使用，用于绑定某个动态的值<br><code>v-on</code> 用于监听 DOM 事件，参数是监听的事件名<br><code>v-text</code> 会将数据解释为普通文本<br><code>v-html</code> 渲染html，将绑定的数据输出为真正的HTML<br><code>v-model</code><br><code>v-if</code>/<code>v-if-else</code>/<code>v-else</code> 用于条件渲染<br><code>v-show</code> 用于控制元素的显示或隐藏<br><code>v-for</code><br><code>v-pre</code><br><code>v-once``v-cloak</code></p>',9),i=a("div",{class:"custom-container tip"},[a("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[a("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[a("circle",{cx:"12",cy:"12",r:"9"}),a("path",{d:"M12 8h.01"}),a("path",{d:"M11 12h1v4h1"})])]),a("p",{class:"custom-container-title"},"v-if与v-show的区别"),a("p",null,[a("code",null,"v-if"),n("在编译过程中会转化成三元表达式条件不满足时不渲染此节点，在运行中很少改变条件，不需要频繁切换的场景时使用"),a("br"),a("code",null,"v-show"),n(" 会被编译成指令，当条件不满足时通过控制"),a("code",null,"display"),n("样式来控制元素的显示隐藏，适用于需要频繁切换显示状态的场景")])],-1),d=s(`<div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token comment">&lt;!-- v-bind常规用法 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>url<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> ... <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">:src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>imagePath<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token comment">&lt;!-- v-bind还可以绑定动态参数
 1. 这里的 attributeName 会被作为一个 JavaScript 表达式进行动态求值，
 求得的值将会作为最终的参数来使用。
 例如，如果你的组件实例有一个 data property attributeName，其值为 &quot;href&quot;，
 那么这个绑定将等价于 v-bind:href
 2. 同理，也可以可以使用动态参数为一个动态的事件名绑定处理函数
 即当 eventName 的值为 &quot;focus&quot; 时，v-on:[eventName] 将等价于 v-on:focus
--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>[attributeName]</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>url<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> ... <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">:[attributeName]</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>url<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> ... <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name"><span class="token namespace">v-on:</span>[eventName]</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>doSomething<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> ... <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">@[eventName]</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>doSomething<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> ... <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- v-on --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">v-on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>clickMe<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>clickMe<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- v-on也可以加事件修饰符
     修饰符 (modifier) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。
     例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()
--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name"><span class="token namespace">v-on:</span>submit.prevent</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>onSubmit<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">@submit.prevent</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>onSubmit<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="生命周期" tabindex="-1"><a class="header-anchor" href="#生命周期" aria-hidden="true">#</a> 生命周期</h2><p>生命周期就是vue 从开始创建到销毁的过程，分为四大步（创建，挂载， 更新，销毁），每一步又分为两小步，如 <code>beforeCreate</code>，<code>created</code>。<code>beforeCreate</code>前，也就是<code>new Vue</code> 的时候会初始化事件和生命周期；<br><code>beforeCreate</code> 和<code>created</code>之间会挂载Data，绑定事件；接下来会根据el 挂载页面元素，如果没有设置el 则生命周期结束，直到手动挂载；<code>el</code>挂载结束后，根据<code>templete</code>/<code>outerHTML(el)</code>渲染页面；在 <code>beforeMount </code>前虚拟 <code>DOM</code>已经创建完成；之后在 <code>mounted</code>前，将 vm.$el 替换掉页面元素<code>el</code>;<code>mounted </code>将虚拟<code>dom</code>挂载到真实页面（此时页面已经全部渲染完成）；之后发生数据变化时触发<code>beforeUpdate </code>和<code>updated</code>进行一些操作；最后主动调用销毁函数或者组件自动销毁时 <code>beforeDestroy</code>，手动撤销监听事件，计时器等；<code>destroyed</code>时仅存在<code>Dom</code>节点，其他所有东西已自动销毁。这就是我所理解的<code>vue</code>的一个完整的生命周期。</p><h3 id="异步请求通常在哪一步发起" tabindex="-1"><a class="header-anchor" href="#异步请求通常在哪一步发起" aria-hidden="true">#</a> 异步请求通常在哪一步发起</h3><p>可以在<code>created</code>、<code>beforeMount</code>、<code>mounted</code>中进行异步请求，因为在这三个钩子函数中<code>data</code>已经创建，可以将服务器端返回的值进行赋值<br>如果异步请求不需要依赖<code>DOM</code>推荐加载<code>created</code>中调用异步请求，因为在created中能更快获取到服务端数据减少页面loading</p><h3 id="生命周期中两个特殊的方法" tabindex="-1"><a class="header-anchor" href="#生命周期中两个特殊的方法" aria-hidden="true">#</a> 生命周期中两个特殊的方法</h3><ol><li><strong>computed（计算属性）</strong>：</li></ol><p>返回一个函数，当data里面的值发生变化时执行，但是不能处理一些复杂的逻辑，<strong>计算属性会基于其响应式依赖被缓存</strong></p><ol start="2"><li><strong>watch （监听属性）</strong>：</li></ol><p>监听data里面某个值的变化，当发生变化时执行，可以处理一些复杂的逻辑</p>`,10),r=a("div",{class:"custom-container tip"},[a("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[a("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[a("circle",{cx:"12",cy:"12",r:"9"}),a("path",{d:"M12 8h.01"}),a("path",{d:"M11 12h1v4h1"})])]),a("p",{class:"custom-container-title"},"computed和watch的区别"),a("ol",null,[a("li",null,"computed能完成的功能，watch都可以完成。"),a("li",null,"watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作")]),a("p",null,[n("所被vue管理的函数，最好写成普通函数，这样this的执行才是vm或组件实例对象；"),a("br"),n("所有不被vue管理的函数（定时器回调函数、ajax的回调函数等最好写成箭头函数）这样this的执行才是vm或组件实例对象")])],-1),k=a("p",null,[a("a",{name:"ze2ec"})],-1),m=a("h3",{id:"为什么data是一个函数",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#为什么data是一个函数","aria-hidden":"true"},"#"),n(" 为什么data是一个函数")],-1),v=a("p",null,[a("code",null,"data"),n("之所以是一个函数，是因为一个组件可能会多处调用，而每一次调用就会执行data函数并返回新的数据对象，这样，可以避免多处调用之间的数据污染。 "),a("a",{name:"srEIF"})],-1);function h(g,b){return e(),o("div",null,[l,c(" more "),u,i,d,r,k,m,v])}const q=t(p,[["render",h],["__file","01-vue_base.html.vue"]]);export{q as default};
